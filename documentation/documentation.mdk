Title         : Linux 下动态链接库的使用
subTitle      : 编译、链接和加载
Author        : 崔利伟
Affiliation   : 电子科技大学计算机科学与工程学院
Email         : cui@hellolw.com
Bibliography  : example.bib
Doc class     : [reprint,nocopyrightspace]style/sigplanconf.cls
Package       : [UTF8]ctex
name-references   : 参考
name-abstract     : 概要
name-contents     :  目录

[TITLE]

~ Abstract
本文主要叙述了动态链接库的编译、链接和加载过程并具体讲解了其中的一些细节问题。
~

~ TexRaw
% any commands necessary for your particular style
\keywords{动态链接库，编译链接与加载}
~

# 动态链接库概述     { #sec-intro }
## 库的概要回顾
我们所说的“库”，指的是为了将一部分代码复用或者隐藏底层细节而制成的模块。据此开发者便可以方便地进行二进制级别的复用而不必获得源码，因此库是“模块化编程”的重要组成部分。我们常见的动态链接库有`GNU`实现的标准库`libstdc++.so`，`Intel`公司的`libmkl.so`等。

~ Note
事实上任何代码均可以制成库，但由于`C++`语言对于类、多态等概念并没有实现上的约束，导致编译期多态（模板）和运行时多态（虚表）的实现均可以由编译器厂商自行决定，所以造成二进制接口互不兼容，或者说不可保证兼容。因此多数库中的代码均由`extern "C"`加入函数之前来避免编译器为支持重载而进行的名字混淆。
~

## 与静态库的联系
目前的主流操作系统均支持动态链接库和静态链接库的使用。这里的”动态”“静态”之分，主要指的是二进制代码是以什么方式被载入内存的。静态库本质上是一组目标文件的集合，在链接过程中与其余的目标文件进行符号解析及地址重定位操作。这样将会在每一个最终生成的结果中保留一份库的副本（一般来说是库的一部分，即使用了能满足最终结果中缺少的那部分符号表的目标文件）。这样的优点是不必对外界有着过多的依赖，但缺点同样明显：每个程序都保存了一份库的副本，尤其对于常用的库可能会有上千份同样的副本；其次是会对版本迭代造成巨大的负担，所有使用旧版本的程序必须重新链接。为了解决这个两个问题，我们希望能把程序模块化，变成独立的文件而非变成一个文件。

## 动态链接库概要
使用模块的思想，我们可以将需要的库以另一种方式进行使用：在内存中只保留一份库的副本，而将链接操作推迟到加载甚至运行时再进行。我们常见的的库和日常使用的“插件”功能都是作为动态库被来使用的。这样就可以解决对于内存以及磁盘的浪费以及版本迭代问题。进一步说，由于动态库常驻内存，它既可以减少物理页面的换入换出，又可以提高CPU 缓存的命中率，所以是对我们之前提出的问题的很好的的解法。

# 编译动态链接库
我们知道动态库最终也会加载入内存进行重定位。但一般的程序指令和数据都会或多或少地依赖绝对地址的引用，而程序又可能依赖多个动态库，所以每个动态库都不能假设自己在进程虚拟地址空间中的位置。操作系统早期这个问题可以通过给已知的模块预留空间来解决，但随着程序的日益复杂这个方案显示出了不可弥补的缺陷。为了解决这个问题，出现了称作“装载时重定位”和“地址无关”的概念和相应技术。

## 装载时重定位
“地址无关”的基本思想是在链接时对于所有需要绝对地址的引用均不作重定位，而将这个过程推迟到加载时进行。因为对于每个进程都拥有一份动态库可修改数据部分的副本，所以这么做可以解决数据部分的重定位的问题。但由于动态库的指令部分在内存中仅有一份副本，不能像数据部分一样直接修改来完成重定位。所以我们引入了“地址无关代码”的概念。

## 地址无关代码
地址无关代码指的是把指令中需要修改的部分提出来并和数据部分放在一起，这样其他指令部分可以不变，不同进程通过修改自己的副本部分来达到复用动态库的目的。

## 动态链接库的相关结构
### `.dynamic`段
`.dynamic`段保存了一些动态链接器所需的基本信息，比如动态库的`soname`，依所赖的对象以及符号表的位置，重定向表的位置等。
~ Note
动态库的`soname`是该动态库在内存中的标识符，在动态库的查找过程中十分重要。
~
### 动态符号表
Linux 下的可执行文件、库及目标文件均属于`ELF`文件。而所有的`ELF`文件均维护了段`.symtab`，也即符号表。它保存了所有关于该文件的符号的定义和引用。而动态链接库又维护了段`.dynsym`，也即动态符号表。动态符号表只保存与动态链接相关的符号，而不保存只用于模块内部的符号。可以认为动态符号表是符号表的一个子集，并且不会被`strip`命令删去。通过阅读动态符号表我们可以了解到该文件有哪些符号未定义需要外部导入，那些符号已有定义可以向外导出。当通过各种办法（静态链接、动态链接）均不可解析出某个未定义的符号时运行时会报错。

### 动态链接重定位表
当文件中引用了其他模块的符号时我们便需要在适当时刻将这些未定义的引用修正，也即需要重定位。静态链接的程序中未知的地址均会在链接过程中被修正，而动态连接的程序则需要在加载时或者运行时进行数据段中绝对地址引用的修正（通过“地址独立代码”技术代码段已不存在绝对地址的引用）。动态链接的重定向表主要是段`.rel.dyn`和`.rel.plt`，前者是对数据引用的修正，后者是对函数的修正。

当动态链接器需要对某个符号进行重定位时，它将在全局符号表中查找该符号的地址。当查找到后将该地址填入重定位表通过偏移量指定的特定位置来完成地址的重定位。

# 装载动态库
## 可执行文件的装载
当一个可执行文件被要求执行时，操作系统会首先创建一个虚拟地址空间，之后检查文件头，确定魔数匹配，然后从文件头取出每个段并按照每个段的不同要求将其映射到进程虚拟空间的相关位置。由于可执行文件保留了对虚拟地址空间的映射关系，所以可执行文件也叫做“镜像文件”。这个过程可以通过`execve`等函数触发系统调用来完成。之后将控制权转移至可执行文件的入口地址（使用`glibc`运行时库的程序入口地址一般是`_start`->`__libc_start_main`->`main`，也即程序会链接crt1.o 和crtn.o）。

## 动态库的装载
### 程序加载时装载
当可执行文件依赖许多动态连接库时，完成了加载后符号表中仍有许多无效的外部地址。这时操作系统将启动动态链接器来完成这些符号的链接。我们可以通过读取可执行文件中的`.interp`段来获得一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径。`Linux`系统下的动态链接器ld.so本身就是一个动态库，系统将控制权转移给它的入口地址。ld.so在完成自举后再将可执行文件中的符号表与其余动态库的符号表进行重定位。完成这些操作后系统才将控制权真正交给可执行文件的入口。

### 显式运行时装载
当系统支持动态链接库时它往往也支持运行时对于动态库的链接。将可执行文件与libdl.so 相链接，我们便可以在程序运行时将共享库装入内存并进行重定位操作。事实上，libdl.so 就是dl.so 的`C`语言接口。这种运行时加载可以使得程序的模块组织变得灵活，并且可以实现按需加载插件、驱动的功能，于是可以减少程序的启动时间和内存占用。我们可以通过查看`/proc`下进程ID对应的文件下的`map`文件来了解具体哪些库被装载在什么位置。

#共享库的查找过程
