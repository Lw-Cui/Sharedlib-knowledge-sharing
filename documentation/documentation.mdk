Title         : Linux 下动态链接库的使用
subTitle      : 编译、链接和加载
Author        : 崔利伟
Affiliation   : 电子科技大学计算机科学与工程学院
Email         : cui@hellolw.com
Bibliography  : example.bib
Doc class     : [reprint,nocopyrightspace]style/sigplanconf.cls
Package       : [UTF8]ctex
name-references   : 参考
name-abstract     : 概要
name-contents     :  目录

[TITLE]

~ Abstract
本文主要叙述了动态链接库的编译、链接和加载过程并具体讲解了其中的一些细节问题。
~

~ TexRaw
% any commands necessary for your particular style
\keywords{动态链接库，编译链接与加载}
~

# 动态链接库概述     { #sec-intro }
## 库的概要回顾
我们所说的“库”，指的是为了将一部分代码复用或者隐藏底层细节而制成的模块。据此开发者便可以方便地进行二进制级别的复用而不必获得源码，因此库是“模块化编程”的重要组成部分。我们常见的动态链接库有`GNU`实现的标准库`libstdc++.so`，`Intel`公司的`libmkl.so`等。

~ Note
事实上任何代码均可以制成库，但由于`C++`语言对于类、多态等概念并没有实现上的约束，导致编译期多态（模板）和运行时多态（虚表）的实现均可以由编译器厂商自行决定，所以造成二进制接口互不兼容，或者说不可保证兼容。因此多数库中的代码均由`extern "C"`加入函数之前来避免编译器为支持重载而进行的名字混淆。
~

## 与静态库的联系
目前的主流操作系统均支持动态链接库和静态链接库的使用。这里的”动态”“静态”之分，主要指的是二进制代码是以什么方式被载入内存的。静态库本质上是一组目标文件的集合，在链接过程中与其余的目标文件进行符号解析及地址重定位操作。这样将会在每一个最终生成的结果中保留一份库的副本（一般来说是库的一部分，即使用了能满足最终结果中缺少的那部分符号表的目标文件）。这样的优点是不必对外界有着过多的依赖，但缺点同样明显：每个程序都保存了一份库的副本，尤其对于常用的库可能会有上千份同样的副本；其次是会对版本迭代造成巨大的负担，所有使用旧版本的程序必须重新链接。为了解决这个两个问题，我们希望能把程序模块化，变成独立的文件而非变成一个文件。

## 动态链接库概要
使用模块的思想，我们可以将需要的库以另一种方式进行使用：在内存中只保留一份库的副本，而将链接操作推迟到加载甚至运行时再进行。我们常见的的库和日常使用的“插件”功能都是作为动态库被来使用的。这样就可以解决对于内存以及磁盘的浪费以及版本迭代问题。进一步说，由于动态库常驻内存，它既可以减少物理页面的换入换出，又可以提高CPU 缓存的命中率，所以是对我们之前提出的问题的很好的的解法。

# 编译动态库
我们知道动态库最终也会加载入内存进行重定位。但一般的程序指令和数据都会或多或少地依赖绝对地址的引用，而程序又可能依赖多个动态库，所以每个动态库都不能假设自己在进程虚拟地址空间中的位置。操作系统早期这个问题可以通过给已知的模块预留空间来解决，但随着程序的日益复杂这个方案显示出了不可弥补的缺陷。为了解决这个问题，出现了称作“装载时重定位”和“地址无关”的概念和相应技术。

## 装载时重定位
“地址无关”的基本思想是在链接时对于所有需要绝对地址的引用均不作重定位，而将这个过程推迟到加载时进行。因为对于每个进程都拥有一份动态库可修改数据部分的副本，所以这么做可以解决数据部分的重定位的问题。但由于动态库的指令部分在内存中仅有一份副本，不能像数据部分一样直接修改来完成重定位。所以我们引入了“地址无关代码”的概念。

## 地址无关代码
地址无关代码指的是把指令中需要修改的部分提出来并和数据部分放在一起，这样其他指令部分可以不变，不同进程通过修改自己的副本部分来达到复用动态库的目的。

## 动态链接库的相关结构


# 链接动态库

# 加载动态库
## 可执行文件的装载
当一个可执行文件被要求执行时，操作系统会首先创建一个虚拟地址空间，之后检查文件头，确定魔数匹配，然后从文件头取出每个段并按照每个段的不同要求将其映射到进程虚拟空间的相关位置。由于可执行文件保留了对虚拟地址空间的映射关系，所以可执行文件也叫做“镜像文件”。这个过程可以通过`execve`等函数触发系统调用来完成。之后将控制权转移至可执行文件的入口地址（使用`glibc`运行时库的程序入口地址一般是`_start`->`__libc_start_main`->`main`，也即程序会链接crt1.o 和crtn.o）。

## 动态库的加载